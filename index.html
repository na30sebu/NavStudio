<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Animation Editor</title>
  <style>

    


    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: #1a1a1a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
    }

  


    .page-wrapper {
      height: 100vh;
      overflow-y: auto;
    }

    .editor {
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: fit-content;
    }

    .toolbar {
      background: #2a2a2a;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: stretch;
      width: 200px;
      flex-shrink: 0;
      border-radius: 0.5rem;
    }

    .tool-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: stretch;
      padding: 0.5rem;
      background: #333;
      border-radius: 0.5rem;
    }

    .tool-button {
      width: 2.5rem;
      height: 2.5rem;
      border: none;
      background: #444;
      color: #fff;
      border-radius: 0.25rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .tool-button:hover {
      background: #555;
    }

    .tool-button.active {
      background: #4a90e2;
      transform: scale(1.05);
      box-shadow: 0 2px 4px rgba(74, 144, 226, 0.3);
    }

    .main-content {
      height: 100%;
      display: flex;
      flex-direction: row;
      gap: 1rem;
      padding: 1rem;
      background: #222;
      position: relative;
    }

    .canvas-area {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      width: 100%;
    }

    .canvas-container {
      position: relative;
      background: #fff;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      border-radius: 0.5rem;
      overflow: hidden;
    }

    #canvas {
      display: block;
    }

    #selectionCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .layers-section {
      background: #2a2a2a;
      border-top: 1px solid #3a3a3a;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .layers-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .layer-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      overflow-y: auto;
      max-height: 150px;
    }

    .layer-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: #333;
      border-radius: 0.25rem;
      cursor: pointer;
    }

    .layer-item.active {
      background: #4a90e2;
    }

    .layer-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .layer-visibility {
      width: 1.5rem;
      height: 1.5rem;
      padding: 0;
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      opacity: 0.7;
    }

    .layer-visibility.visible {
      opacity: 1;
    }

    .layer-opacity {
      width: 60px;
      height: 4px;
      -webkit-appearance: none;
      background: #444;
      border-radius: 2px;
    }

    .layer-opacity::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }

    .timeline {
      background: #2a2a2a;
      border-top: 1px solid #3a3a3a;
      padding: 1rem;
    }

    .timeline-controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .timeline-scrubber {
      position: relative;
      height: 24px;
      background: #333;
      border-radius: 0.25rem;
      margin-bottom: 1rem;
      cursor: pointer;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
    }

    .timeline-progress {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #5ba0f2);
      border-radius: 0.25rem;
      pointer-events: none;
      box-shadow: 0 0 8px rgba(74, 144, 226, 0.4);
    }

    .timeline-handle {
      position: absolute;
      top: -4px;
      width: 12px;
      height: 32px;
      background: linear-gradient(180deg, #fff, #f0f0f0);
      border-radius: 6px;
      transform: translateX(-50%);
      cursor: grab;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      border: 2px solid #4a90e2;
    }

    .timeline-handle:active {
      cursor: grabbing;
    }

    .frames-container {
      display: flex;
      gap: 0.5rem;
      overflow-x: auto;
      padding: 0.5rem;
      background: #333;
      border-radius: 0.5rem;
      min-height: 120px;
    }

    .frame {
      flex: 0 0 100px;
      height: 100px;
      background: #444;
      border-radius: 0.25rem;
      position: relative;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .frame:hover {
      transform: scale(1.05);
    }

    .frame.active {
      outline: 3px solid #4a90e2;
      box-shadow: 0 0 12px rgba(74, 144, 226, 0.5);
      transform: scale(1.02);
    }

    .frame-preview {
      width: 100%;
      height: 80px;
      background: #fff;
      border-radius: 0.25rem 0.25rem 0 0;
    }

    .frame-number {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      text-align: center;
      padding: 0.25rem;
      font-size: 0.75rem;
      background: rgba(0,0,0,0.5);
      border-radius: 0 0 0.25rem 0.25rem;
    }

    .frame-duration {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #888;
    }

    .dropzone {
      position: absolute;
      inset: 0;
      background: rgba(74, 144, 226, 0.2);
      border: 2px dashed #4a90e2;
      border-radius: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .dropzone.active {
      opacity: 1;
    }

    input[type="color"] {
      width: 2.5rem;
      height: 2.5rem;
      padding: 0;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
    }

    input[type="range"] {
      width: 100px;
    }

    input[type="number"] {
      width: 4rem;
      padding: 0.25rem;
      background: #444;
      border: none;
      border-radius: 0.25rem;
      color: #fff;
    }

    .btn {
      padding: 0.5rem 1rem;
      background: #4a90e2;
      border: none;
      border-radius: 0.25rem;
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }

    .btn:hover {
      background: #357abd;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(74, 144, 226, 0.4);
    }

    .brush-settings {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: #2a2a2a;
      padding: 1rem;
      border-radius: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 10;
    }

    .brush-settings label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .brush-settings input[type="range"] {
      width: 100px;
    }

    .context-menu {
      position: fixed;
      background: #2a2a2a;
      border-radius: 0.25rem;
      padding: 0.5rem;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 1000;
    }

    .context-menu button {
      display: block;
      width: 100%;
      padding: 0.5rem 1rem;
      background: none;
      border: none;
      color: #fff;
      text-align: left;
      cursor: pointer;
    }

    .context-menu button:hover {
      background: #444;
    }

    .nav-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: #333;
      color: #fff;
      text-align: center;
      padding: 0.5rem;
      font-size: 1rem;
      border-radius: 0 0 0.5rem 0.5rem;
    }

    /* Touch-friendly improvements */
    .tool-button, .btn, .layer-visibility {
      min-height: 44px;
      min-width: 44px;
    }
    .timeline-handle {
      min-width: 44px;
      min-height: 44px;
    }
    .frame {
      min-width: 44px;
      min-height: 44px;
    }
    .layer-item {
      min-height: 44px;
    }
    .timeline-scrubber {
      min-height: 44px;
    }
  </style>
</head>
<body>
  <div class="page-wrapper">
    <div class="editor">
    <div class="main-content">
        <div class="toolbar">
          <div class="tool-group">
            <button class="tool-button active" data-tool="brush" title="Brush">üñåÔ∏è</button>
            <button class="tool-button" data-tool="eraser" title="Eraser">‚ö™</button>
            <button class="tool-button" data-tool="fill" title="Fill">ü™£</button>
            <button class="tool-button" data-tool="select" title="Rectangle Select">‚¨ö</button>
            <button class="tool-button" data-tool="lasso" title="Lasso Select">‚úÇÔ∏è</button>
            <button class="tool-button" data-tool="move" title="Move">‚úã</button>
          </div>

          <div class="tool-group">
            <input type="color" id="colorPicker" value="#000000" title="Color">
            <input type="range" id="sizeSlider" min="1" max="50" value="5" title="Size">
            <span id="sizeValue">5px</span>
          </div>

          <div class="tool-group">
            <label>
              <input type="checkbox" id="onionSkin"> Onion Skin
            </label>
            <input type="number" id="fps" value="12" min="1" max="60" title="FPS">
            <span>FPS</span>
          </div>

          <div class="tool-group">
            <button class="btn" id="undo">Undo</button>
            <button class="btn" id="copy" disabled>Copy</button>
            <button class="btn" id="paste" disabled>Paste</button>
          </div>
        </div>
        <div class="canvas-area">
         <div class="canvas-container">
           <canvas id="canvas"></canvas>
           <canvas id="selectionCanvas"></canvas>
           <div class="nav-bar">NavStudio</div>
         </div>
         <div class="dropzone">Drop images here</div>
         <div class="brush-settings" style="display: none;">
           <label>
             Smoothing
             <input type="range" id="smoothing" min="0" max="1" step="0.1" value="0.5">
           </label>
           <label>
             Pressure
             <input type="checkbox" id="pressureEnabled" checked>
           </label>
         </div>
       </div>
     </div>

    <div class="timeline">
       <div class="timeline-controls">
         <button class="btn" id="playPause">‚ñ∂Ô∏è Play</button>
         <button class="btn" id="videoPlayback" style="display: none;">üé• Play Video</button>
         <button class="btn" id="addFrame">+ Frame</button>
         <button class="btn" id="duplicateFrame">Duplicate</button>
         <button class="btn" id="deleteFrame">Delete</button>
         <input type="file" id="importImages" accept="image/*" multiple style="display: none">
         <button class="btn" onclick="document.getElementById('importImages').click()">Import</button>
         <button class="btn" id="exportGif">Export PNG (First Frame)</button>
         <button class="btn" id="exportVideo">üé• Export Video</button>
         <button class="btn" id="exportFrames">üì¶ Export Frames (ZIP)</button>
       </div>
       <div class="timeline-scrubber">
         <div class="timeline-progress"></div>
         <div class="timeline-handle"></div>
       </div>
       <div class="layers-section">
         <div class="layers-header">
           <h3>Layers</h3>
           <button class="btn" id="addLayer">+ Layer</button>
         </div>
         <div class="layer-list" id="layerList"></div>
       </div>
       <div class="frames-container" id="framesContainer"></div>
     </div>
    </div>
  </div>
<h1 style="background-color: white; color: black;">NavStudio</h1>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js"></script>
  <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/webm-writer@1.0.0/dist/webm-writer.min.js"></script>
  <script>
    // Alternative video export using MediaRecorder API
    class VideoExporter {
      constructor() {
        this.mediaRecorder = null;
        this.recordedChunks = [];
      }

      async exportAnimation(frames, fps, canvas) {
        return new Promise(async (resolve, reject) => {
          try {
            // Create a temporary canvas for recording
            const recordCanvas = document.createElement('canvas');
            recordCanvas.width = canvas.width;
            recordCanvas.height = canvas.height;
            const recordCtx = recordCanvas.getContext('2d');

            // Create a video stream from the canvas
            const stream = recordCanvas.captureStream(fps);

            // Try different codecs in order of preference
            let options = { mimeType: 'video/webm;codecs=vp9' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
              options = { mimeType: 'video/webm;codecs=vp8' };
              if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options = { mimeType: 'video/webm' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                  throw new Error('WebM recording not supported');
                }
              }
            }

            this.mediaRecorder = new MediaRecorder(stream, options);

            this.recordedChunks = [];

            this.mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                this.recordedChunks.push(event.data);
              }
            };

            this.mediaRecorder.onstop = () => {
              const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
              resolve(blob);
            };

            // Start recording
            this.mediaRecorder.start();

            // Draw each frame with proper timing
            for (let i = 0; i < frames.length; i++) {
              // Clear canvas with transparent background (not white, preserve original colors)
              recordCtx.clearRect(0, 0, recordCanvas.width, recordCanvas.height);

              // Create temporary canvas with frame data
              const tempCanvas = document.createElement('canvas');
              tempCanvas.width = recordCanvas.width;
              tempCanvas.height = recordCanvas.height;
              const tempCtx = tempCanvas.getContext('2d');
              // Fill with white background first, then draw frame data
              tempCtx.fillStyle = '#FFFFFF';
              tempCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);

              // Draw frame data with proper color representation
              const frameImageData = new ImageData(
                new Uint8ClampedArray(frames[i].data.data),
                frames[i].data.width,
                frames[i].data.height
              );
              recordCtx.putImageData(frameImageData, 0, 0);

              // Draw the frame to recording canvas
              recordCtx.drawImage(tempCanvas, 0, 0);

              // Request animation frame to ensure proper rendering
              await new Promise(resolve => requestAnimationFrame(resolve));

              // Wait for the frame duration
              const frameDuration = 1000 / fps;
              await new Promise(resolve => setTimeout(resolve, frameDuration));
            }

            // Add a short delay to ensure last frame is recorded
            await new Promise(resolve => setTimeout(resolve, 200));

            // Stop recording
            this.mediaRecorder.stop();

          } catch (error) {
            reject(error);
          }
        });
      }
    }

    // Make VideoExporter globally available
    window.VideoExporter = VideoExporter;
  </script>


  
  <script>

    
    class AnimationEditor {
      constructor() {
        console.log('AnimationEditor constructor started');
        this.canvas = document.getElementById('canvas');
        this.selectionCanvas = document.getElementById('selectionCanvas');
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
        this.selectionCtx = this.selectionCanvas.getContext('2d', { willReadFrequently: true });
        
        this.isDrawing = false;
        this.layers = [];
        this.currentLayer = 0;
        this.currentFrame = 0;
        this.currentTool = 'brush';
        this.brushSize = 5;
        this.color = '#000000';
        this.onionSkin = false;
        this.fps = 12;
        this.isPlaying = false;
        this.playInterval = null;
        
        // New properties
        this.smoothing = 0.5;
        this.pressureEnabled = true;
        this.points = [];
        this.selection = null;
        this.clipboard = null;
        this.isDragging = false;
        this.dragOffset = null;
        this.lastPoint = null;
        this.lassoPoints = [];

        // FFmpeg initialization
        this.ffmpeg = null;
        this.isFFmpegLoaded = false;
        this.videoElement = null;

        this.initCanvas();
        this.initEvents();
        this.createInitialLayer();
        this.updateUI();
        this.initFFmpeg();
        console.log('AnimationEditor initialized');
      }

      initCanvas() {
        this.canvas.width = 800;
        this.canvas.height = 600;
        this.selectionCanvas.width = 800;
        this.selectionCanvas.height = 600;

        // Set canvas to use proper color space and high quality
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        // Fill canvas with white background initially
        this.ctx.fillStyle = '#FFFFFF';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }

      createInitialLayer() {
        this.addLayer();
      }

      addLayer() {
        const layer = {
          id: Date.now().toString(),
          name: `Layer ${this.layers.length + 1}`,
          frames: [this.createFrame()],
          visible: true,
          opacity: 1
        };
        this.layers.push(layer);
        this.currentLayer = this.layers.length - 1;
        this.updateUI();
      }

      createFrame() {
         // Create frame with white background data
         const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
         // Fill with white (all pixels set to white with full alpha)
         for (let i = 0; i < imageData.data.length; i += 4) {
           imageData.data[i] = 255;     // Red
           imageData.data[i + 1] = 255; // Green
           imageData.data[i + 2] = 255; // Blue
           imageData.data[i + 3] = 255; // Alpha
         }

         return {
           id: Date.now().toString(),
           data: imageData,
           duration: 1000 / this.fps,
           history: []
         };
       }

      saveState() {
        const layer = this.layers[this.currentLayer];
        const frame = layer.frames[this.currentFrame];
        const nonWhitePixels = this.countNonWhitePixels(frame.data);
        console.log('Saving state for layer:', this.currentLayer, 'frame:', this.currentFrame, 'history length before:', frame.history.length, 'non-white pixels:', nonWhitePixels);
        const dataURL = this.canvas.toDataURL('image/png');
        frame.history.push(dataURL);
        console.log('After save, history length:', frame.history.length, 'state saved as dataURL');
        this.updateUndoButton();
      }

      undo() {
        const layer = this.layers[this.currentLayer];
        const frame = layer.frames[this.currentFrame];
        console.log('Undo called for layer:', this.currentLayer, 'frame:', this.currentFrame, 'history length:', frame.history.length);
        if (frame.history.length > 0) {
          const dataURL = frame.history.pop();
          console.log('Restoring from dataURL, length:', dataURL.length);
          const img = new Image();
          img.onload = () => {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(img, 0, 0);
            // Update frame.data
            frame.data = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            const nonWhitePixels = this.countNonWhitePixels(frame.data);
            console.log('Undid, history length now:', frame.history.length, 'restored non-white pixels:', nonWhitePixels);
            this.loadFrame(this.currentFrame);
            this.updateUndoButton();
          };
          img.src = dataURL;
        } else {
          console.log('No history to undo');
        }
      }

      startDrawing(e) {
        console.log('startDrawing called, tool:', this.currentTool, 'isDrawing:', this.isDrawing, 'event type:', e.type, 'touches:', e.touches ? e.touches.length : 'none');
        this.isDrawing = true;
        if (e.touches) {
          e.clientX = e.touches[0].clientX;
          e.clientY = e.touches[0].clientY;
          e.pressure = e.touches[0].force || 1;
          console.log('Touch start: clientX:', e.clientX, 'clientY:', e.clientY, 'force:', e.pressure);
        } else {
          console.log('Mouse start: clientX:', e.clientX, 'clientY:', e.clientY);
        }
        const pos = this.getMousePos(e);
        console.log('Start position: x:', pos.x, 'y:', pos.y);

        if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
          this.saveState();
          this.points = [];
          this.addPoint(pos.x, pos.y, e.pressure || 1);
        } else if (this.currentTool === 'select') {
          this.selection = {
            startX: pos.x,
            startY: pos.y,
            width: 0,
            height: 0
          };
        } else if (this.currentTool === 'lasso') {
          this.lassoPoints = [pos];
          this.drawLassoSelection();
        } else if (this.currentTool === 'fill') {
          this.floodFill(pos.x, pos.y);
        } else if (this.currentTool === 'move') {
          // Check if clicking on existing selection
          if (this.selection && this.isPointInSelection(pos)) {
            this.isDragging = true;
            this.dragOffset = {
              x: pos.x - this.selection.x,
              y: pos.y - this.selection.y
            };
          }
        }

        this.lastPoint = pos;
      }

      addPoint(x, y, pressure) {
        const point = { x, y, pressure };
        this.points.push(point);
        
        if (this.points.length > 3) {
          const xc = (this.points[1].x + this.points[2].x) / 2;
          const yc = (this.points[1].y + this.points[2].y) / 2;
          const pressure = (this.points[1].pressure + this.points[2].pressure) / 2;
          
          this.ctx.beginPath();
          this.ctx.moveTo(this.points[0].x, this.points[0].y);
          this.ctx.quadraticCurveTo(
            this.points[1].x,
            this.points[1].y,
            xc,
            yc
          );
          
          this.ctx.strokeStyle = this.currentTool === 'eraser' ? '#FFFFFF' : this.color;
          this.ctx.lineWidth = this.brushSize * (this.pressureEnabled ? pressure : 1);
          this.ctx.stroke();
          
          this.points.shift();
        }
      }

      floodFill(x, y) {
        // Convert coordinates to integers
        x = Math.floor(x);
        y = Math.floor(y);

        // Check bounds
        if (x < 0 || x >= this.canvas.width || y < 0 || y >= this.canvas.height) {
          return;
        }

        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const pixels = imageData.data;
        const startPos = (y * this.canvas.width + x) * 4;

        // Get the color we're trying to fill
        const startR = pixels[startPos];
        const startG = pixels[startPos + 1];
        const startB = pixels[startPos + 2];
        const startA = pixels[startPos + 3];

        // Get the fill color
        const fillR = parseInt(this.color.substr(1, 2), 16);
        const fillG = parseInt(this.color.substr(3, 2), 16);
        const fillB = parseInt(this.color.substr(5, 2), 16);

        this.saveState();

        // Don't fill if the target color is the same as fill color
        if (startR === fillR && startG === fillG && startB === fillB) {
          return;
        }

        const stack = [[x, y]];
        const seen = new Set();

        while (stack.length) {
          const [cx, cy] = stack.pop();
          const pos = (cy * this.canvas.width + cx) * 4;

          if (
            cx < 0 || cx >= this.canvas.width ||
            cy < 0 || cy >= this.canvas.height ||
            seen.has(`${cx},${cy}`) ||
            pixels[pos] !== startR ||
            pixels[pos + 1] !== startG ||
            pixels[pos + 2] !== startB ||
            pixels[pos + 3] !== startA
          ) {
            continue;
          }

          pixels[pos] = fillR;
          pixels[pos + 1] = fillG;
          pixels[pos + 2] = fillB;
          pixels[pos + 3] = 255;

          seen.add(`${cx},${cy}`);
          stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
        }

        this.ctx.putImageData(imageData, 0, 0);
        this.saveCurrentFrame();
      }

      draw(e) {
        if (!this.isDrawing) return;
        console.log('draw called, event type:', e.type, 'touches:', e.touches ? e.touches.length : 'none');
        if (e.touches) {
          e.clientX = e.touches[0].clientX;
          e.clientY = e.touches[0].clientY;
          e.pressure = e.touches[0].force || 1;
          console.log('Touch move: clientX:', e.clientX, 'clientY:', e.clientY, 'force:', e.pressure);
        } else {
          console.log('Mouse move: clientX:', e.clientX, 'clientY:', e.clientY);
        }
        const pos = this.getMousePos(e);
        console.log('Draw position: x:', pos.x, 'y:', pos.y, 'tool:', this.currentTool);

        if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
          this.addPoint(pos.x, pos.y, e.pressure || 1);
        } else if (this.currentTool === 'select') {
          this.updateSelection(pos);
        } else if (this.currentTool === 'lasso') {
          this.lassoPoints.push(pos);
          this.drawLassoSelection();
        } else if (this.currentTool === 'move' && this.isDragging && this.selection) {
           // Move the selection while dragging
           this.selection.x = pos.x - this.dragOffset.x;
           this.selection.y = pos.y - this.dragOffset.y;
           this.drawSelection();
         }

        this.lastPoint = pos;
      }

      stopDrawing() {
        if (!this.isDrawing) return;
        this.isDrawing = false;

        if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
          this.saveCurrentFrame();
        } else if (this.currentTool === 'select' || this.currentTool === 'lasso') {
          this.finalizeSelection();
        } else if (this.currentTool === 'move') {
          this.isDragging = false;
          // When finished moving, paste the content and clear selection
          if (this.clipboard) {
            this.paste();
            this.selectionCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.selection = null;
          }
        }
      }

      updateSelection(pos) {
        if (!this.selection) return;
        
        this.selection.width = pos.x - this.selection.startX;
        this.selection.height = pos.y - this.selection.startY;
        this.drawSelection();
      }

      drawSelection() {
        this.selectionCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.selectionCtx.strokeStyle = '#4a90e2';
        this.selectionCtx.setLineDash([5, 5]);
        this.selectionCtx.strokeRect(
          this.selection.startX,
          this.selection.startY,
          this.selection.width,
          this.selection.height
        );
      }

      drawLassoSelection() {
        this.selectionCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.selectionCtx.strokeStyle = '#4a90e2';
        this.selectionCtx.setLineDash([5, 5]);
        this.selectionCtx.beginPath();
        this.selectionCtx.moveTo(this.lassoPoints[0].x, this.lassoPoints[0].y);
        
        for (let i = 1; i < this.lassoPoints.length; i++) {
          this.selectionCtx.lineTo(this.lassoPoints[i].x, this.lassoPoints[i].y);
        }
        
        this.selectionCtx.stroke();
      }

      finalizeSelection() {
          if (this.currentTool === 'select') {
            const x = Math.min(this.selection.startX, this.selection.startX + this.selection.width);
            const y = Math.min(this.selection.startY, this.selection.startY + this.selection.height);
            const w = Math.abs(this.selection.width);
            const h = Math.abs(this.selection.height);

            this.selection = { x, y, width: w, height: h };
            // Enable copy button and automatically copy selection
            document.getElementById('copy').disabled = false;
            this.copy();
          } else if (this.currentTool === 'lasso') {
            // Create bounding box for lasso selection
            const xs = this.lassoPoints.map(p => p.x);
            const ys = this.lassoPoints.map(p => p.y);
            const x = Math.min(...xs);
            const y = Math.min(...ys);
            const width = Math.max(...xs) - x;
            const height = Math.max(...ys) - y;

            this.selection = { x, y, width, height, path: this.lassoPoints };
            // Enable copy button
            document.getElementById('copy').disabled = false;
            // If clipboard has content, paste at center of lasso path
            if (this.clipboard) {
              this.paste();
            } else {
              // Otherwise, copy the selection
              this.copy();
            }
          }
        }

      moveSelection(dx, dy) {
        if (!this.selection) return;

        this.selection.x += dx;
        this.selection.y += dy;
        this.drawSelection();
      }

      isPointInSelection(pos) {
        if (!this.selection) return false;

        return pos.x >= this.selection.x &&
               pos.x <= this.selection.x + this.selection.width &&
               pos.y >= this.selection.y &&
               pos.y <= this.selection.y + this.selection.height;
      }

      copy() {
          console.log('copy() called, selection:', this.selection);
          if (!this.selection) return;

          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = this.selection.width;
          tempCanvas.height = this.selection.height;
          const tempCtx = tempCanvas.getContext('2d');

          // Fill with transparent background first
          tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

          if (this.selection.path) {
            // Lasso selection - create clipping path
            tempCtx.beginPath();
            tempCtx.moveTo(
              this.selection.path[0].x - this.selection.x,
              this.selection.path[0].y - this.selection.y
            );

            for (let i = 1; i < this.selection.path.length; i++) {
              tempCtx.lineTo(
                this.selection.path[i].x - this.selection.x,
                this.selection.path[i].y - this.selection.y
              );
            }

            tempCtx.closePath();
            tempCtx.clip();
          }

          // Draw the selected portion of the canvas
          tempCtx.drawImage(
            this.canvas,
            this.selection.x,
            this.selection.y,
            this.selection.width,
            this.selection.height,
            0,
            0,
            this.selection.width,
            this.selection.height
          );

          this.clipboard = {
            image: tempCanvas,
            width: this.selection.width,
            height: this.selection.height,
            hasPath: !!this.selection.path
          };

          document.getElementById('paste').disabled = false;
          console.log('Copied selection:', this.selection, 'clipboard created');
        }

      paste() {
          console.log('paste() called, clipboard:', this.clipboard);
          if (!this.clipboard) {
            alert('Nothing to paste. Copy a selection first.');
            return;
          }

          // Determine paste position
          let pasteX, pasteY;
          if (this.selection && this.selection.path) {
            // Calculate centroid of lasso path
            const points = this.selection.path;
            const sumX = points.reduce((sum, p) => sum + p.x, 0);
            const sumY = points.reduce((sum, p) => sum + p.y, 0);
            const centroidX = sumX / points.length;
            const centroidY = sumY / points.length;
            pasteX = centroidX - this.clipboard.width / 2;
            pasteY = centroidY - this.clipboard.height / 2;
          } else {
            // Paste at current mouse position or center of canvas
            pasteX = this.lastPoint ? this.lastPoint.x - this.clipboard.width / 2 : this.canvas.width / 2 - this.clipboard.width / 2;
            pasteY = this.lastPoint ? this.lastPoint.y - this.clipboard.height / 2 : this.canvas.height / 2 - this.clipboard.height / 2;
          }

          console.log('Pasting at:', pasteX, pasteY, 'clipboard size:', this.clipboard.width, this.clipboard.height);

          this.saveState();
          this.ctx.drawImage(
            this.clipboard.image,
            pasteX,
            pasteY
          );

          console.log('drawImage called, now saving frame');
          this.saveCurrentFrame();
          console.log('Pasted at:', pasteX, pasteY, 'frame saved');
          // Ensure the frame is redrawn after paste
          this.loadFrame(this.currentFrame);
        }

      getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        let clientX, clientY;
        let isTouch = false;
        if (e.touches) {
          isTouch = true;
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }
        const pos = {
          x: (clientX - rect.left) * (this.canvas.width / rect.width),
          y: (clientY - rect.top) * (this.canvas.height / rect.height)
        };
        console.log(`getMousePos: ${isTouch ? 'Touch' : 'Mouse'}, clientX: ${clientX}, clientY: ${clientY}, rect left: ${rect.left}, top: ${rect.top}, calculated x: ${pos.x}, y: ${pos.y}`);
        return pos;
      }

      addFrame() {
        // Save current frame first
        this.saveCurrentFrame();

        const layer = this.layers[this.currentLayer];
        // Create new frame with current canvas content (continues from current frame)
        const newFrame = {
          id: Date.now().toString(),
          data: this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height),
          duration: 1000 / this.fps,
          history: []
        };
        layer.frames.push(newFrame);
        this.currentFrame = layer.frames.length - 1;
        this.updateUI();
      }

      duplicateFrame() {
        const layer = this.layers[this.currentLayer];
        const frame = layer.frames[this.currentFrame];
        const newFrame = {
          id: Date.now().toString(),
          data: new ImageData(
            new Uint8ClampedArray(frame.data.data),
            frame.data.width,
            frame.data.height
          ),
          duration: frame.duration,
          history: [...frame.history]
        };
        layer.frames.splice(this.currentFrame + 1, 0, newFrame);
        this.currentFrame++;
        this.updateUI();
      }

      deleteFrame() {
        const layer = this.layers[this.currentLayer];
        if (layer.frames.length <= 1) return;
        layer.frames.splice(this.currentFrame, 1);
        this.currentFrame = Math.max(0, this.currentFrame - 1);
        this.updateUI();
      }

      saveCurrentFrame() {
        console.log('saveCurrentFrame() called for layer:', this.currentLayer, 'frame:', this.currentFrame);
        const layer = this.layers[this.currentLayer];
        layer.frames[this.currentFrame].data = this.ctx.getImageData(
          0, 0, this.canvas.width, this.canvas.height
        );
        console.log('Frame data updated, imageData length:', layer.frames[this.currentFrame].data.data.length);
        this.updateFramePreview(this.currentFrame);
      }

      loadFrame(frameIndex) {
          console.log('loadFrame called, onionSkin:', this.onionSkin, 'currentFrame:', frameIndex, 'currentLayer:', this.currentLayer, 'layers count:', this.layers.length);
          this.currentFrame = frameIndex;
          this.clearCanvas();

          // Draw all visible layers
          const visibleLayers = this.layers.filter(layer => layer.visible);
          console.log(`Number of visible layers: ${visibleLayers.length}`);
          visibleLayers.forEach((layer, i) => {
            console.log(`Rendering layer ${this.layers.indexOf(layer)} (order ${i}) with opacity ${layer.opacity}`);
            // Create a temporary canvas for this layer
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.canvas.width;
            tempCanvas.height = this.canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            const layerIndex = this.layers.indexOf(layer);
            const nonWhitePixels = this.countNonWhitePixels(layer.frames[frameIndex].data);
            console.log(`Putting image data for layer ${layerIndex}, non-white pixels: ${nonWhitePixels}`);
            tempCtx.putImageData(layer.frames[frameIndex].data, 0, 0);

            // Draw to main canvas with opacity
            this.ctx.globalAlpha = layer.opacity;
            this.ctx.drawImage(tempCanvas, 0, 0);
            this.ctx.globalAlpha = 1; // Reset
            if (layerIndex === this.currentLayer) {
              console.log('Drawn current layer, imageData non-white pixels:', nonWhitePixels);
            }
          });

        // Draw onion skin for current layer on top
        if (this.onionSkin && this.layers[this.currentLayer] && this.layers[this.currentLayer].visible) {
          const layer = this.layers[this.currentLayer];

          // Draw previous frame onion
          if (frameIndex > 0) {
            console.log('Drawing onion skin for layer', this.currentLayer, 'previous frame', frameIndex - 1);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.canvas.width;
            tempCanvas.height = this.canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(layer.frames[frameIndex - 1].data, 0, 0);
            this.ctx.globalAlpha = 0.3;
            this.ctx.drawImage(tempCanvas, 0, 0);
            this.ctx.globalAlpha = 1;
            console.log('Previous onion drawn with 30% alpha');
          }
          // Draw next frame onion
          if (frameIndex < layer.frames.length - 1) {
            console.log('Drawing onion skin for layer', this.currentLayer, 'next frame', frameIndex + 1);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.canvas.width;
            tempCanvas.height = this.canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(layer.frames[frameIndex + 1].data, 0, 0);
            this.ctx.globalAlpha = 0.2; // Slightly less opacity for next
            this.ctx.drawImage(tempCanvas, 0, 0);
            this.ctx.globalAlpha = 1;
            console.log('Next onion drawn with 20% alpha');
          }
        }
        
        this.ctx.globalAlpha = 1;
        this.updateUI();
      }

      clearCanvas() {
        // Clear with white background to maintain consistency
        this.ctx.fillStyle = '#FFFFFF';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }

      updateFramePreview(frameIndex) {
        const frame = document.querySelector(
          `.frame[data-index="${frameIndex}"] .frame-preview`
        );
        if (!frame) return;

        const ctx = frame.getContext('2d');
        ctx.clearRect(0, 0, frame.width, frame.height);

        // Draw the actual frame data instead of current canvas
        const layer = this.layers[this.currentLayer];
        if (layer && layer.frames[frameIndex]) {
          // Scale the frame data to fit the preview size
          const frameData = layer.frames[frameIndex].data;
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = this.canvas.width;
          tempCanvas.height = this.canvas.height;
          const tempCtx = tempCanvas.getContext('2d');
          // Ensure proper color representation
          tempCtx.putImageData(frameData, 0, 0);

          ctx.drawImage(tempCanvas, 0, 0, frame.width, frame.height);
        }
      }

      togglePlay() {
        this.isPlaying = !this.isPlaying;
        if (this.isPlaying) {
          this.play();
        } else {
          this.stop();
        }
      }

      play() {
        let frameIndex = this.currentFrame;
        this.playInterval = setInterval(() => {
          frameIndex = (frameIndex + 1) % this.layers[this.currentLayer].frames.length;
          this.loadFrame(frameIndex);
        }, 1000 / this.fps);
      }

      stop() {
        if (this.playInterval) {
          clearInterval(this.playInterval);
          this.playInterval = null;
        }
      }

      exportGif() {
        try {
          const frames = this.layers[this.currentLayer].frames;
          console.log(`Exporting GIF for layer ${this.currentLayer} with ${frames.length} frames`);

          if (frames.length === 0) {
            alert('No frames to export!');
            return;
          }

          // Export current frame as PNG with proper color preservation
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = this.canvas.width;
          tempCanvas.height = this.canvas.height;
          const tempCtx = tempCanvas.getContext('2d');

          // Draw the current frame with proper color data and white background
          const currentFrameData = frames[this.currentFrame].data;

          // Fill with white background first
          tempCtx.fillStyle = '#FFFFFF';
          tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

          // Then draw the frame data
          const imageData = new ImageData(
            new Uint8ClampedArray(currentFrameData.data),
            currentFrameData.width,
            currentFrameData.height
          );
          tempCtx.putImageData(imageData, 0, 0);

          // Download as PNG with maximum quality
          tempCanvas.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `frame_${this.currentFrame + 1}.png`;
            a.click();
            URL.revokeObjectURL(url);
          }, 'image/png', 1.0);

        } catch (error) {
          console.error('PNG export failed:', error);
          alert('Export failed. Check console for details.');
        }
      }

      countNonWhitePixels(imageData) {
        let count = 0;
        for (let i = 0; i < imageData.data.length; i += 4) {
          if (imageData.data[i] !== 255 || imageData.data[i+1] !== 255 || imageData.data[i+2] !== 255) {
            count++;
          }
        }
        return count;
      }

      async initFFmpeg() {
        try {
          const { createFFmpeg } = FFmpeg;
          const { fetchFile, toBlobURL } = FFmpegUtil;

          this.ffmpeg = createFFmpeg({ log: true });
          this.ffmpeg.on('log', ({ message }) => {
            console.log(message);
          });

          // Load FFmpeg from CDN
          await this.ffmpeg.load({
            coreURL: await toBlobURL('https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js', 'text/javascript'),
            wasmURL: await toBlobURL('https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.wasm', 'application/wasm'),
            workerURL: await toBlobURL('https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.worker.js', 'text/javascript'),
          });

          this.isFFmpegLoaded = true;
          console.log('FFmpeg loaded successfully');
        } catch (error) {
          console.error('Failed to load FFmpeg:', error);
          this.isFFmpegLoaded = false;
        }
      }

      async exportVideo() {
        try {
          // Show loading message
          const originalText = document.getElementById('exportVideo').textContent;
          document.getElementById('exportVideo').textContent = '‚è≥ Exporting...';
          document.getElementById('exportVideo').disabled = true;

          const frames = this.layers[this.currentLayer].frames;

          // Try WebM export first (simpler and more reliable)
          await this.exportWebM(frames);

        } catch (error) {
          console.error('All video export methods failed:', error);
          alert('Video export failed. Try using the ZIP export for frames instead.');
        } finally {
          // Reset button
          document.getElementById('exportVideo').textContent = 'üé• Export Video';
          document.getElementById('exportVideo').disabled = false;
        }
      }

      async exportWebM(frames) {
        try {
          // Try MediaRecorder API first (most reliable)
          if (this.canvas.captureStream) {
            const exporter = new VideoExporter();
            const videoBlob = await exporter.exportAnimation(frames, this.fps, this.canvas);

            // Download the video
            const url = URL.createObjectURL(videoBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'animation.webm';
            a.click();

            // Set up video playback
            const video = this.createVideoPlayback();
            video.src = url;
            document.getElementById('videoPlayback').style.display = 'inline-block';

            // Clean up
            setTimeout(() => {
              URL.revokeObjectURL(url);
            }, 1000);

            return; // Success, don't try other methods
          }

          // Fallback to WebM writer if MediaRecorder not available
          if (typeof WebMWriter !== 'undefined') {
            // Create WebM writer
            const writer = new WebMWriter({
              quality: 0.95,
              frameRate: this.fps
            });

            // Add each frame
            for (let i = 0; i < frames.length; i++) {
              const tempCanvas = document.createElement('canvas');
              tempCanvas.width = this.canvas.width;
              tempCanvas.height = this.canvas.height;
              const tempCtx = tempCanvas.getContext('2d');
              tempCtx.putImageData(frames[i].data, 0, 0);

              // Add frame to WebM
              writer.addFrame(tempCanvas);
            }

            // Complete the WebM file
            const webmBlob = await writer.complete();

            // Download the WebM file
            const url = URL.createObjectURL(webmBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'animation.webm';
            a.click();

            // Set up video playback
            const video = this.createVideoPlayback();
            video.src = url;
            document.getElementById('videoPlayback').style.display = 'inline-block';

            // Clean up
            setTimeout(() => {
              URL.revokeObjectURL(url);
            }, 1000);
          } else {
            throw new Error('No video export method available');
          }

        } catch (error) {
          console.error('All video export methods failed:', error);
          throw error;
        }
      }

      async exportVideoFFmpeg(frames) {
        if (!this.isFFmpegLoaded || !this.ffmpeg) {
          throw new Error('FFmpeg not available');
        }

        // Create sequence of images
        for (let i = 0; i < frames.length; i++) {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = this.canvas.width;
          tempCanvas.height = this.canvas.height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.putImageData(frames[i].data, 0, 0);

          // Convert canvas to blob
          const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
          const arrayBuffer = await blob.arrayBuffer();

          // Write to FFmpeg filesystem
          await this.ffmpeg.FS('writeFile', `frame_${i.toString().padStart(4, '0')}.png`, new Uint8Array(arrayBuffer));
        }

        // Run FFmpeg command to create video
        await this.ffmpeg.run(
          '-framerate', this.fps.toString(),
          '-i', 'frame_%04d.png',
          '-c:v', 'libx264',
          '-pix_fmt', 'yuv420p',
          'output.mp4'
        );

        // Read the output file
        const data = this.ffmpeg.FS('readFile', 'output.mp4');

        // Create download link and set up video playback
        const blob = new Blob([data.buffer], { type: 'video/mp4' });
        const url = URL.createObjectURL(blob);

        // Set video source for playback
        const video = this.createVideoPlayback();
        video.src = url;
        document.getElementById('videoPlayback').style.display = 'inline-block';

        // Create download link
        const a = document.createElement('a');
        a.href = url;
        a.download = 'animation.mp4';
        a.click();

        // Clean up after a delay to allow download
        setTimeout(() => {
          URL.revokeObjectURL(url);
        }, 1000);

        // Clean up
        for (let i = 0; i < frames.length; i++) {
          this.ffmpeg.FS('unlink', `frame_${i.toString().padStart(4, '0')}.png`);
        }
        this.ffmpeg.FS('unlink', 'output.mp4');
      }

      async exportFrames() {
        try {
          // Show loading message
          const originalText = document.getElementById('exportFrames').textContent;
          document.getElementById('exportFrames').textContent = '‚è≥ Creating ZIP...';
          document.getElementById('exportFrames').disabled = true;

          const zip = new JSZip();
          const frames = this.layers[this.currentLayer].frames;

          // Add each frame to the ZIP
          for (let i = 0; i < frames.length; i++) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.canvas.width;
            tempCanvas.height = this.canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Fill with white background first, then draw frame data
            tempCtx.fillStyle = '#FFFFFF';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Draw frame data with proper color preservation
            const frameImageData = new ImageData(
              new Uint8ClampedArray(frames[i].data.data),
              frames[i].data.width,
              frames[i].data.height
            );
            tempCtx.putImageData(frameImageData, 0, 0);

            // Convert canvas to blob with maximum quality
            const blob = await new Promise(resolve =>
              tempCanvas.toBlob(resolve, 'image/png', 1.0)
            );
            zip.file(`frame_${(i + 1).toString().padStart(4, '0')}.png`, blob);
          }

          // Generate ZIP file
          const zipBlob = await zip.generateAsync({ type: 'blob' });

          // Download the ZIP
          saveAs(zipBlob, 'animation_frames.zip');

        } catch (error) {
          console.error('Frame export failed:', error);
          alert('Frame export failed. Check console for details.');
        } finally {
          // Reset button
          document.getElementById('exportFrames').textContent = 'üì¶ Export Frames (ZIP)';
          document.getElementById('exportFrames').disabled = false;
        }
      }

      createVideoPlayback() {
        // Create video element if it doesn't exist
        if (!this.videoElement) {
          this.videoElement = document.createElement('video');
          this.videoElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 80vw;
            max-height: 80vh;
            background: #000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: none;
            z-index: 2000;
          `;
          this.videoElement.controls = true;

          // Add close button
          const closeBtn = document.createElement('button');
          closeBtn.textContent = '‚úï';
          closeBtn.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            z-index: 2001;
          `;
          closeBtn.onclick = () => {
            this.videoElement.style.display = 'none';
            this.videoElement.pause();
          };

          // Add overlay background
          const overlay = document.createElement('div');
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.8);
            z-index: 1999;
            display: none;
            cursor: pointer;
          `;
          overlay.onclick = () => {
            this.videoElement.style.display = 'none';
            this.videoElement.pause();
          };

          document.body.appendChild(overlay);
          document.body.appendChild(this.videoElement);
          document.body.appendChild(closeBtn);
        }

        return this.videoElement;
      }

      showVideoPlayback() {
        const video = this.createVideoPlayback();
        if (video.src) {
          video.style.display = 'block';
          video.play();
        } else {
          alert('No video available. Export a video first.');
        }
      }

      handleImport(files) {
        Array.from(files).forEach(file => {
          const reader = new FileReader();
          reader.onload = e => {
            const img = new Image();
            img.onload = () => {
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
              this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);
              this.addFrame();
              this.saveCurrentFrame();
            };
            img.src = e.target.result;
           };
          reader.readAsDataURL(file);
        });
      }

      updateUndoButton() {
        const layer = this.layers[this.currentLayer];
        const frame = layer.frames[this.currentFrame];
        const undoBtn = document.getElementById('undo');
        console.log('Updating undo button for layer:', this.currentLayer, 'frame:', this.currentFrame, 'history length:', frame.history.length, 'enabled:', frame.history.length > 0);
        if (frame.history.length === 0) {
          undoBtn.style.opacity = '0.5';
          undoBtn.style.cursor = 'not-allowed';
          undoBtn.style.pointerEvents = 'none';
        } else {
          undoBtn.style.opacity = '1';
          undoBtn.style.cursor = 'pointer';
          undoBtn.style.pointerEvents = 'auto';
        }
      }

      updateUI() {
        this.updateLayerList();
        this.updateFrames();
        this.updateTimeline();
        this.updateUndoButton();
        document.getElementById('playPause').textContent =
          this.isPlaying ? '‚èπÔ∏è Stop' : '‚ñ∂Ô∏è Play';
      }

      updateLayerList() {
        const layerList = document.getElementById('layerList');
        layerList.innerHTML = '';
        
        this.layers.forEach((layer, i) => {
          const div = document.createElement('div');
          div.className = `layer-item ${i === this.currentLayer ? 'active' : ''}`;
          div.innerHTML = `
            <div class="layer-controls">
              <button class="layer-visibility ${layer.visible ? 'visible' : ''}" onclick="editor.toggleLayerVisibility(${i})" ontouchstart="event.preventDefault(); editor.toggleLayerVisibility(${i})">
                üëÅÔ∏è
              </button>
              <input
                type="range"
                class="layer-opacity"
                value="${layer.opacity * 100}"
                min="0"
                max="100"
                oninput="editor.setLayerOpacity(${i}, this.value)"
                ontouchstart="event.preventDefault()"
                ontouchmove="event.preventDefault()"
              >
              <span>${layer.name}</span>
            </div>
          `;
          div.onclick = (e) => {
            if (!e.target.classList.contains('layer-visibility') &&
                !e.target.classList.contains('layer-opacity')) {
              this.setCurrentLayer(i);
            }
          };
          div.ontouchstart = (e) => {
            e.preventDefault();
            if (!e.target.classList.contains('layer-visibility') &&
                !e.target.classList.contains('layer-opacity')) {
              this.setCurrentLayer(i);
            }
          };
          layerList.appendChild(div);
        });
      }

      toggleLayerVisibility(index) {
        this.layers[index].visible = !this.layers[index].visible;
        this.loadFrame(this.currentFrame);
        this.updateUI();
      }

      setLayerOpacity(index, value) {
        this.layers[index].opacity = value / 100;
        console.log(`Layer ${index} opacity updated to ${this.layers[index].opacity}`);
        this.loadFrame(this.currentFrame);
      }

      updateFrames() {
        const container = document.getElementById('framesContainer');
        container.innerHTML = '';
        
        this.layers[this.currentLayer].frames.forEach((frame, i) => {
          const div = document.createElement('div');
          div.className = `frame ${i === this.currentFrame ? 'active' : ''}`;
          div.setAttribute('data-index', i);
          div.innerHTML = `
            <canvas class="frame-preview" width="100" height="80"></canvas>
            <div class="frame-number">${i + 1}</div>
            <div class="frame-duration">${Math.round(frame.duration)}ms</div>
          `;
          div.onclick = () => this.loadFrame(i);
          div.ontouchstart = (e) => {
            e.preventDefault();
            this.loadFrame(i);
          };
          container.appendChild(div);
          this.updateFramePreview(i);
        });
      }

      updateTimeline() {
        const progress = document.querySelector('.timeline-progress');
        const handle = document.querySelector('.timeline-handle');
        const frameCount = this.layers[this.currentLayer].frames.length;
        const percentage = frameCount > 1 ? (this.currentFrame / (frameCount - 1)) * 100 : 0;

        progress.style.width = `${percentage}%`;
        handle.style.left = `${percentage}%`;
      }

      setCurrentLayer(index) {
        // Adjust currentFrame to be valid for the new layer
        this.currentFrame = Math.min(this.currentFrame, this.layers[index].frames.length - 1);
        this.currentLayer = index;
        this.updateUI();
      }

      initEvents() {
        console.log('initEvents started');
        // Canvas events
        this.canvas.addEventListener('mousedown', e => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', e => this.draw(e));
        this.canvas.addEventListener('mouseup', () => this.stopDrawing());
        this.canvas.addEventListener('mouseout', () => this.stopDrawing());
        // Touch events for canvas
        this.canvas.addEventListener('touchstart', e => {
          e.preventDefault();
          this.startDrawing(e);
        });
        this.canvas.addEventListener('touchmove', e => {
          e.preventDefault();
          this.draw(e);
        });
        this.canvas.addEventListener('touchend', e => {
          e.preventDefault();
          this.stopDrawing();
        });

        // Tool settings
        document.getElementById('colorPicker').addEventListener('input', e => {
          this.color = e.target.value;
        });

        document.getElementById('sizeSlider').addEventListener('input', e => {
          this.brushSize = e.target.value;
          document.getElementById('sizeValue').textContent = `${this.brushSize}px`;
        });
        document.getElementById('sizeSlider').addEventListener('touchstart', e => e.preventDefault());
        document.getElementById('sizeSlider').addEventListener('touchmove', e => e.preventDefault());

        document.getElementById('smoothing').addEventListener('input', e => {
          this.smoothing = parseFloat(e.target.value);
        });
        document.getElementById('smoothing').addEventListener('touchstart', e => e.preventDefault());
        document.getElementById('smoothing').addEventListener('touchmove', e => e.preventDefault());

        document.getElementById('pressureEnabled').addEventListener('change', e => {
          this.pressureEnabled = e.target.checked;
        });

        document.getElementById('onionSkin').addEventListener('change', e => {
          console.log('Onion Skin toggled:', e.target.checked);
          this.onionSkin = e.target.checked;
          this.loadFrame(this.currentFrame);
        });

        document.getElementById('fps').addEventListener('input', e => {
          this.fps = parseInt(e.target.value);
        });
        document.getElementById('fps').addEventListener('touchstart', e => e.preventDefault());
        document.getElementById('fps').addEventListener('touchmove', e => e.preventDefault());

        // Timeline scrubbing
        const scrubber = document.querySelector('.timeline-scrubber');
        scrubber.addEventListener('mousedown', e => {
          const rect = scrubber.getBoundingClientRect();
          const percentage = (e.clientX - rect.left) / rect.width;
          const frameIndex = Math.floor(percentage * (this.layers[this.currentLayer].frames.length - 1));
          this.loadFrame(frameIndex);
        });
        scrubber.addEventListener('touchstart', e => {
          e.preventDefault();
          const rect = scrubber.getBoundingClientRect();
          const percentage = (e.touches[0].clientX - rect.left) / rect.width;
          const frameIndex = Math.floor(percentage * (this.layers[this.currentLayer].frames.length - 1));
          this.loadFrame(frameIndex);
        });
        scrubber.addEventListener('touchmove', e => {
          e.preventDefault();
          const rect = scrubber.getBoundingClientRect();
          const percentage = (e.touches[0].clientX - rect.left) / rect.width;
          const frameIndex = Math.floor(percentage * (this.layers[this.currentLayer].frames.length - 1));
          this.loadFrame(frameIndex);
        });

        // Layer and frame controls
        document.getElementById('addLayer').onclick = () => this.addLayer();
        document.getElementById('addFrame').onclick = () => this.addFrame();
        document.getElementById('duplicateFrame').onclick = () => this.duplicateFrame();
        document.getElementById('deleteFrame').onclick = () => this.deleteFrame();
        document.getElementById('playPause').onclick = () => this.togglePlay();
        document.getElementById('exportGif').onclick = () => this.exportGif();
        document.getElementById('exportVideo').onclick = () => this.exportVideo();
        document.getElementById('exportFrames').onclick = () => this.exportFrames();
        document.getElementById('videoPlayback').onclick = () => this.showVideoPlayback();
        // Touch handlers for buttons
        document.getElementById('addLayer').addEventListener('touchstart', e => {
          e.preventDefault();
          this.addLayer();
        });
        document.getElementById('addFrame').addEventListener('touchstart', e => {
          e.preventDefault();
          this.addFrame();
        });
        document.getElementById('duplicateFrame').addEventListener('touchstart', e => {
          e.preventDefault();
          this.duplicateFrame();
        });
        document.getElementById('deleteFrame').addEventListener('touchstart', e => {
          e.preventDefault();
          this.deleteFrame();
        });
        document.getElementById('playPause').addEventListener('touchstart', e => {
          e.preventDefault();
          this.togglePlay();
        });
        document.getElementById('exportGif').addEventListener('touchstart', e => {
          e.preventDefault();
          this.exportGif();
        });
        document.getElementById('exportVideo').addEventListener('touchstart', e => {
          e.preventDefault();
          this.exportVideo();
        });
        document.getElementById('exportFrames').addEventListener('touchstart', e => {
          e.preventDefault();
          this.exportFrames();
        });
        document.getElementById('videoPlayback').addEventListener('touchstart', e => {
          e.preventDefault();
          this.showVideoPlayback();
        });

        // Copy/Paste
        document.getElementById('copy').onclick = () => {
          console.log('Copy button clicked, selection:', this.selection);
          if (this.selection) {
            this.copy();
            document.getElementById('paste').disabled = false;
            alert('Selection copied! Now click Paste to place it.');
          } else {
            alert('Please select an area first using the Select tool.');
          }
        };
        document.getElementById('paste').onclick = () => {
          console.log('Paste button clicked, clipboard:', this.clipboard);
          if (this.clipboard) {
            this.paste();
            // Clear clipboard after paste
            this.clipboard = null;
            document.getElementById('paste').disabled = true;
            this.selectionCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.selection = null;
          } else {
            alert('Nothing to paste. Copy a selection first.');
          }
        };
        document.getElementById('copy').addEventListener('touchstart', e => {
          e.preventDefault();
          console.log('Copy button touchstart triggered');
          document.getElementById('copy').click();
        });
        document.getElementById('paste').addEventListener('touchstart', e => {
          e.preventDefault();
          console.log('Paste button touchstart triggered');
          document.getElementById('paste').click();
        });

        document.getElementById('undo').addEventListener('click', () => {
          console.log('Undo button clicked');
          this.undo();
        });
        document.getElementById('undo').addEventListener('touchstart', e => {
          e.preventDefault();
          console.log('Undo button touchstart triggered');
          this.undo();
        });

        // Import
        document.getElementById('importImages').addEventListener('change', e => {
          this.handleImport(e.target.files);
        });

        // Tool selection
        document.querySelectorAll('.tool-button').forEach(button => {
          button.addEventListener('click', e => {
            document.querySelectorAll('.tool-button').forEach(b =>
              b.classList.remove('active')
            );
            e.target.classList.add('active');
            this.currentTool = e.target.dataset.tool;
            
            // Show/hide brush settings
            document.querySelector('.brush-settings').style.display =
              this.currentTool === 'brush' ? 'block' : 'none';
          });
          button.addEventListener('touchstart', e => {
            e.preventDefault();
            console.log('Tool button touchstart: tool:', e.target.dataset.tool);
            button.click();
          });
        });

        // Drag and drop
        const dropzone = document.querySelector('.dropzone');
        this.canvas.parentElement.addEventListener('dragenter', e => {
          e.preventDefault();
          dropzone.classList.add('active');
        });

        this.canvas.parentElement.addEventListener('dragleave', e => {
          e.preventDefault();
          dropzone.classList.remove('active');
        });

        this.canvas.parentElement.addEventListener('dragover', e => {
          e.preventDefault();
        });

        this.canvas.parentElement.addEventListener('drop', e => {
          e.preventDefault();
          dropzone.classList.remove('active');
          this.handleImport(e.dataTransfer.files);
        });

        // Undo shortcut
        document.addEventListener('keydown', e => {
          if (e.ctrlKey && e.key === 'z') {
            console.log('Ctrl+Z pressed');
            e.preventDefault();
            this.undo();
          }
        });
        console.log('initEvents completed');
      }
    }

    // Initialize the editor when the page loads
    window.addEventListener('load', () => {
      window.editor = new AnimationEditor();
    });

    
  </script>
</body>
</html>

